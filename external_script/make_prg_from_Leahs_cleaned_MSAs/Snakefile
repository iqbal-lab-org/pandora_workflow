from pathlib import Path
from snakemake.utils import min_version
from glob import glob
import fileinput
import os
min_version("5.4.0")

# ======================================================
# Config files
# ======================================================
configfile: "config.yaml"


# ======================================================
# Variables
# ======================================================
input_fasta_dir = config["input_fasta_dir"]
output_dir = config["output_dir"]
run_MSA = bool(config["run_MSA"])

genes = []
for file in glob(f"{input_fasta_dir}/*.fa"):
    file_is_empty = os.stat(file).st_size == 0
    if not file_is_empty:
        gene = Path(file).name.replace(".fa", "")
        genes.append(gene)


rule all:
    input:
        expand(output_dir + "/prgs/custom/{gene}.prg.fa", gene=genes),
        output_dir + "/prgs/prg.fa",
        output_dir + "/msas/msas.csv"



rule cp_or_run_MSA:
    input:
        previous_gene = input_fasta_dir + "/{gene}.fa"
    output:
        msa = output_dir + "/msas/custom/{gene}.fa"
    params:
        run_MSA = run_MSA,
        log_level = "DEBUG",
    threads: 1
    shadow: "shallow"
    resources:
        mem_mb = lambda wildcards, attempt: {1: 2000, 2: 4000, 3: 8000}.get(attempt, 32000)
    log:
        "logs/cp_or_run_MSA/{gene}.log"
    singularity: config["make_prg_dependencies_img"]
    script:
        "cp_or_run_MSA.py"

rule make_msas_csv:
    input:
        msas = expand(rules.cp_or_run_MSA.output.msa, gene=genes)
    output:
        msas_csv = output_dir + "/msas/msas.csv"
    threads: 1
    resources:
        mem_mb = 100
    log:
        "logs/make_msas_csv.log"
    run:
        with open(output.msas_csv, "w") as fout:
            print("msas_absolute_paths", file=fout)
            for msa in input.msas:
                absolute_path_msa = Path(msa).absolute()
                print(str(absolute_path_msa), file=fout)



rule make_prg:
    input:
        msa = rules.cp_or_run_MSA.output.msa
    output:
        prg = output_dir + "/prgs/custom/{gene}.prg.fa"
    threads: 1
    resources:
        mem_mb = lambda wildcards, attempt: {1: 4000, 2: 16000, 3: 32000}.get(attempt, 64000)
    params:
        log_level = "DEBUG",
        make_prg_script = "make_prg_from_msa.py",
        max_nesting_lvl = config.get("max_nesting_lvl", 5),
        prefix = lambda wildcards, output: output.prg.replace("".join(Path(output.prg).suffixes), ""),
    singularity: config["make_prg_dependencies_img"]
    log:
        "logs/make_prg/{gene}.log"
    script:
        "make_prg.py"


def is_header(line):
    return line.startswith(">")


def get_PRG_sequence(line):
    prg_sequence = line.rstrip()
    line_ends_digit = prg_sequence[-1].isdigit()
    if line_ends_digit:
        prg_sequence += " "
    return prg_sequence


def concatenate_several_prgs_into_one(input_prgs, output_prg):
    with open(output_prg, "w") as fout, fileinput.input(input_prgs) as fin:
        for line in fin:
            if is_header(line):
                fout.write(line)
            else:
                prg_sequence = get_PRG_sequence(line)
                fout.write(prg_sequence + "\n")



rule aggregate_prgs:
    input:
        prgs = expand(output_dir + "/prgs/custom/{gene}.prg.fa", gene=genes)
    output:
        prg = output_dir + "/prgs/prg.fa"
    threads: 1
    resources:
        mem_mb = lambda wildcards, attempt: 2000 * attempt
    log:
        "logs/aggregate_prgs.log"
    run:
        concatenate_several_prgs_into_one(input.prgs, output.prg)
